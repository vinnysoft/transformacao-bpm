-- @nsURI MetaModeloUML=http://www.eclipse.org/uml2/3.0.0/UML
-- @nsURI MetaModeloBPMN=http://stp.eclipse.org/bpmn


module BPMNparaAtividades;
create ModeloSaida: MetaModeloUML from ModeloEntrada: MetaModeloBPMN;

--Helper para verificar se a atividade é uma atividade inicial.
helper context MetaModeloBPMN!Activity def: isInitialNode(): Boolean =
	if self.activityType.toString().startsWith('EventStart') and self.activityType <>
			#EventStartTimer then
		true
	else
		false
	endif;

--Helper para verificar se a atividade é um EventStartTimer.
helper context MetaModeloBPMN!Activity def: isInitialTimerNode(): Boolean =
	if self.activityType = #EventStartTimer then
		true
	else
		false
	endif;

--Helper para verificar se a atividade é uma atividade final.
helper context MetaModeloBPMN!Activity def: isFinalNode(): Boolean =
	if self.activityType.toString().startsWith('EventEnd') then
		true
	else
		false
	endif;

--Helper para verificar se source name é null
helper context MetaModeloBPMN!SequenceEdge def: isSourceNameNull(): Boolean =
	if self.source.name.toString().size() = 0 then
		true
	else
		false
	endif;

--Helper para verificar se o target name é null
helper context MetaModeloBPMN!SequenceEdge def: isTargetNameNull(): Boolean =
	if self.target.name.toString().size() = 0 then
		true
	else
		false
	endif;

--Rule para criar uma atividade e modelo UML por cada diagrama BPMN.
rule DiagramaBPMN2ModeloUML {
	from
		ModeloBPMN: MetaModeloBPMN!BpmnDiagram
	to
		ModeloUML: MetaModeloUML!Model (
			name <- 'Modelo UML (gerado)'
		),
		AtividadeUML: MetaModeloUML!Activity (
			name <- 'Atividade (gerada)',
			package <- ModeloUML,
			node <- MetaModeloUML!ActivityNode.allInstances(),
			partition <- MetaModeloUML!ActivityPartition.allInstances(),
			edge <- MetaModeloUML!ActivityEdge.allInstances()
		)
}

-- rules para eventos de inicio
rule InicioBPMN2InicioUML {
	from
		AtividadeInicioBPMN: MetaModeloBPMN!Activity (
			AtividadeInicioBPMN.isInitialNode()
		)
	to
		AtividadeInicioUML: MetaModeloUML!InitialNode (
			name <- AtividadeInicioBPMN.name,
			inPartition <- AtividadeInicioBPMN.lanes.union(AtividadeInicioBPMN.lanes -> collect(lane | lane.pool)),
			incoming <- AtividadeInicioBPMN.incomingEdges,
			outgoing <- AtividadeInicioBPMN.outgoingEdges
		)
}

rule EventStartTimerBPMN2AcceptEventActionUML {
	from
		AtividadeInicioBPMN: MetaModeloBPMN!Activity (
			AtividadeInicioBPMN.isInitialTimerNode()
		)
	to
		AcceptEventActionUML: MetaModeloUML!AcceptEventAction (
			name <- AtividadeInicioBPMN.name,
			inPartition <- AtividadeInicioBPMN.lanes.union(AtividadeInicioBPMN.lanes -> collect(lane | lane.pool)),
			incoming <- AtividadeInicioBPMN.incomingEdges,
			outgoing <- AtividadeInicioBPMN.outgoingEdges
		)
}

-- rules para eventos de fim
rule FimBPMN2FimUML {
	from
		AtividadeFimBPMN: MetaModeloBPMN!Activity (
			AtividadeFimBPMN.activityType.toString().startsWith('EventEnd')
		)
	to
		AtividadeFimUML: MetaModeloUML!ActivityFinalNode (
			name <- AtividadeFimBPMN.name,
			inPartition <- AtividadeFimBPMN.lanes.union(AtividadeFimBPMN.lanes -> collect(lane | lane.pool)),
			incoming <- AtividadeFimBPMN.incomingEdges,
			outgoing <- AtividadeFimBPMN.outgoingEdges
		)
}

rule TaskBPMN2OpaqueAction {
	from
		TaskBPMN: MetaModeloBPMN!Activity (
			TaskBPMN.activityType = #Task
		)
	to
		OpaqueAction: MetaModeloUML!OpaqueAction (
			name <- TaskBPMN.name,
			inPartition <- TaskBPMN.lanes.union(TaskBPMN.lanes -> collect(lane | lane.pool)),
			outgoing <- TaskBPMN.outgoingEdges,
			incoming <- TaskBPMN.incomingEdges
		)
}


-- Gateways
-- Gateway exclusivo
rule ExclusiveGatewayBPMN2DecisionNodeUML {
	from
		ExclusiveGatewayBPMN: MetaModeloBPMN!Activity (
			ExclusiveGatewayBPMN.activityType = #GatewayDataBasedExclusive
		)
	to
		AtividadeEstruturadaUML: MetaModeloUML!DecisionNode (
			name <- 'ExclusiveGateway ID:' + ExclusiveGatewayBPMN.iD,
			inPartition <- ExclusiveGatewayBPMN.lanes.union(ExclusiveGatewayBPMN.lanes -> collect(lane | lane.pool)),
			incoming <- ExclusiveGatewayBPMN.incomingEdges,
			outgoing <- ExclusiveGatewayBPMN.outgoingEdges
		)
}

-- Gateway inclusive
rule InclusiveGatewayBPMN2ForkNodeUML {
	from
		InclusiveGatewayBPMN: MetaModeloBPMN!Activity (
			InclusiveGatewayBPMN.activityType = #GatewayDataBasedInclusive and
					InclusiveGatewayBPMN.outgoingEdges.first() <> InclusiveGatewayBPMN.
					outgoingEdges.last()
		)
	to
		AtividadeEstruturadaUML: MetaModeloUML!ForkNode (
			name <- InclusiveGatewayBPMN.iD,
			inPartition <- InclusiveGatewayBPMN.lanes.union(InclusiveGatewayBPMN.lanes -> collect(lane | lane.pool)),
			incoming <- InclusiveGatewayBPMN.incomingEdges,
			outgoing <- InclusiveGatewayBPMN.outgoingEdges
		)
}

-- Gateway inclusive
rule InclusiveGatewayBPMN2JoinNodeUML {
	from
		InclusiveGatewayBPMN: MetaModeloBPMN!Activity (
			InclusiveGatewayBPMN.activityType = #GatewayDataBasedInclusive and
					InclusiveGatewayBPMN.incomingEdges.first() <> InclusiveGatewayBPMN.
					incomingEdges.last()
		)
	to
		AtividadeEstruturadaUML: MetaModeloUML!JoinNode (
			name <- InclusiveGatewayBPMN.iD,
			inPartition <- InclusiveGatewayBPMN.lanes.union(InclusiveGatewayBPMN.lanes -> collect(lane | lane.pool)),
			incoming <- InclusiveGatewayBPMN.incomingEdges,
			outgoing <- InclusiveGatewayBPMN.outgoingEdges
		)
}

-- Gateway paralelo
rule ParallelGatewayBPMN2ForkNodeUML {
	from
		ParallelGatewayBPMN: MetaModeloBPMN!Activity (
			ParallelGatewayBPMN.activityType = #GatewayParallel and ParallelGatewayBPMN.
					outgoingEdges.first() <> ParallelGatewayBPMN.outgoingEdges.last()
		)
	to
		AtividadeEstruturadaUML: MetaModeloUML!ForkNode (
			name <- ParallelGatewayBPMN.iD,
			inPartition <- ParallelGatewayBPMN.lanes.union(ParallelGatewayBPMN.lanes -> collect(lane | lane.pool)),
			incoming <- ParallelGatewayBPMN.incomingEdges,
			outgoing <- ParallelGatewayBPMN.outgoingEdges
		)
}

rule ParallelGatewayBPMN2JoinNodeUML {
	from
		ParallelGatewayBPMN: MetaModeloBPMN!Activity (
			ParallelGatewayBPMN.activityType = #GatewayParallel and ParallelGatewayBPMN.
					incomingEdges.first() <> ParallelGatewayBPMN.incomingEdges.last()
		)
	to
		AtividadeEstruturadaUML: MetaModeloUML!JoinNode (
			name <- ParallelGatewayBPMN.iD,
			inPartition <- ParallelGatewayBPMN.lanes.union(ParallelGatewayBPMN.lanes -> collect(lane | lane.pool)),
			incoming <- ParallelGatewayBPMN.incomingEdges,
			outgoing <- ParallelGatewayBPMN.outgoingEdges
		)
}

-- Subprocesso
rule SubProcessBPMN2ExpansionRegionUML {
	from
		SubProcessBPMN: MetaModeloBPMN!Activity (
			SubProcessBPMN.activityType = #SubProcess
		)
	to
		ExpansionRegionUML: MetaModeloUML!ExpansionRegion (
			name <- SubProcessBPMN.name,
			inPartition <- SubProcessBPMN.lanes.union(SubProcessBPMN.lanes -> collect(lane | lane.pool)),
			incoming <- SubProcessBPMN.incomingEdges,
			outgoing <- SubProcessBPMN.outgoingEdges
		)
}

-- Rule Data Object para Artefato
rule DataObjectBPMN2ObjectNodeUML {
	from
		DataObjectBPMN: MetaModeloBPMN!DataObject
	to
		--ObjetoUML: MetaModeloUML!ObjectNode (
		ArtefatoUML: MetaModeloUML!Artifact (
			name <- DataObjectBPMN.name
		)
}

-- Rule Association para Object Flow
rule AssociationBPMN2ObjectFlowUML {
	from
		AssociationBPMN: MetaModeloBPMN!Association
	to
		ObjectFlowUML: MetaModeloUML!ObjectFlow (
			name <- AssociationBPMN.source.name + '->' + AssociationBPMN.target.name
		)
}

-- Rule Text Annotation para Comment
rule TextBPMN2CommentUML {
	from
		TextBPMN: MetaModeloBPMN!TextAnnotation
	to
		Comment: MetaModeloUML!Comment (
			body <- TextBPMN.documentation
		)
}

-- Rule para transformação de Group  em Partition
rule GroupBPMN2ActivityGroupUML {
	from
		GrupoBPMN: MetaModeloBPMN!Group
	to
		GrupoUML: MetaModeloUML!ActivityPartition (
			name <- GrupoBPMN.name
		)
}

-- rules para transformação das sequence edge BPMN em control flow UML
rule SequenceEdgeBPM2ControlFlowUML {
	from
		SequenceEdgeBPM: MetaModeloBPMN!SequenceEdge (
			SequenceEdgeBPM.isSourceNameNull() or SequenceEdgeBPM.isTargetNameNull()
		)
	to
		ActivityEdgeUML: MetaModeloUML!ControlFlow (
			name <- SequenceEdgeBPM.source.iD + '->' + SequenceEdgeBPM.target.iD
		)
}

rule SequenceEdgeBPM2ControlFlowUMLNames {
	from
		SequenceEdgeBPM: MetaModeloBPMN!SequenceEdge (
			not SequenceEdgeBPM.isSourceNameNull() and not SequenceEdgeBPM.
					isTargetNameNull()
		)
	to
		ActivityEdgeUML: MetaModeloUML!ControlFlow (
			name <- SequenceEdgeBPM.source.name.toString() + '->' + SequenceEdgeBPM.
					target.name.toString()
		)
}

--Rule para mapear os PoolsBPMN em ActivityPartitions
rule PoolBPM2PartitionUML {
	from
		PoolBPM: MetaModeloBPMN!Pool
	to
		PartitionUML: MetaModeloUML!ActivityPartition (
			name <- PoolBPM.name,
			subpartition <- PoolBPM.lanes
		)
}

--Rule para mapear as LanesBPMN em ActivityPartitions
rule LaneBPM2PartitionUML {
	from
		LaneBPM: MetaModeloBPMN!Lane
	to
		PartitionUML: MetaModeloUML!ActivityPartition (
			name <- LaneBPM.name,
			superPartition <- LaneBPM.pool
		)
}

--Rule para mapear as mensagens BPMN como Control Flow UML
rule MessagingEdgeBPM2ControlFlowUML {
	from
		MessagingEdgeBPM: MetaModeloBPMN!MessagingEdge
	to
		ControlFlowUML: MetaModeloUML!ControlFlow (
			name <- MessagingEdgeBPM.source.name + '->' + MessagingEdgeBPM.target.name,
			source <- MessagingEdgeBPM.source,
			target <- MessagingEdgeBPM.target
		)
}
